<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Rune Slayer Builder</title>
    <link rel="stylesheet" href="css/organizer.css" />
    <link rel="icon" href="./image/icon.png" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
</head>
<body>
    <div id="custom-tooltip" style="display: none; position: absolute; z-index: 1000;"></div>
    <h1>Rune Slayer Builder</h1>
    <div class="main-container">
        <div class="LayoutEquipments">
            <div class="coluna1">
                <div class="equipment-row">
                    <div class="slot" data-slot="ring" data-ring-number="1">Ring 1</div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="ring" data-ring-number="2">Ring 2</div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="ring" data-ring-number="3">Ring 3</div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="ring" data-ring-number="4">Ring 4</div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="lantern">Lantern</div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="fairy">Fairy</div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="race">Race</div>
                </div>
            </div>
            <div class="coluna2">
                <div class="equipment-row">
                    <div class="slot" data-slot="helmet">Helmet</div>
                    <div class="rune-slots">
                        <div class="rune-slot" data-original-number="I">I</div>
                        <div class="rune-slot" data-original-number="II">II</div>
                        <div class="rune-slot" data-original-number="III">III</div>
                        <div class="rune-slot" data-original-number="IV">IV</div>
                    </div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="chest">Chest</div>
                    <div class="rune-slots">
                        <div class="rune-slot" data-original-number="I">I</div>
                        <div class="rune-slot" data-original-number="II">II</div>
                        <div class="rune-slot" data-original-number="III">III</div>
                        <div class="rune-slot" data-original-number="IV">IV</div>
                        <div class="rune-slot" data-original-number="V">V</div>
                        <div class="rune-slot" data-original-number="VI">VI</div>
                    </div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="boots">Boots</div>
                    <div class="rune-slots">
                        <div class="rune-slot" data-original-number="I">I</div>
                        <div class="rune-slot" data-original-number="II">II</div>
                        <div class="rune-slot" data-original-number="III">III</div>
                        <div class="rune-slot" data-original-number="IV">IV</div>
                    </div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="back">Back</div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="weapon1">Weapon</div>
                    <div class="rune-slots">
                        <div class="rune-slot" data-original-number="I">I</div>
                        <div class="rune-slot" data-original-number="II">II</div>
                        <div class="rune-slot" data-original-number="III">III</div>
                    </div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="offhand">Offhand</div>
                    <div class="rune-slots">
                        <div class="rune-slot" data-original-number="I">I</div>
                        <div class="rune-slot" data-original-number="II">II</div>
                        <div class="rune-slot" data-original-number="III">III</div>
                    </div>
                </div>
                <div class="equipment-row">
                    <div class="slot" data-slot="weapon2">Secondary</div>
                    <div class="rune-slots">
                        <div class="rune-slot" data-original-number="I">I</div>
                        <div class="rune-slot" data-original-number="II">II</div>
                        <div class="rune-slot" data-original-number="III">III</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="total-stats-container">
            <div class="stats-header">
                <h2>Total Character Stats</h2>
                
            </div>
            <label class="professions-checkbox-label">
                <input type="checkbox" id="level60-professions" class="professions-checkbox">
                <span>Level 60 Professions</span>
                </label>
            <div class="stats-display">
                <!-- Stats will be populated here -->
            </div>
        </div>

        <div class="">
            <div class="class-container">
            <h2>Class Levels</h2>
            <div class="class-levels-display">
                <div class="total-levels">Total Levels: <span id="total-levels">0</span>/50</div>
                <div class="class-list" id="class-list">
                    <!-- Classes will be populated here -->
                </div>
            </div>
        <div class="export-import-container">
        <div class="export-container">
            <button id="export-build-btn" class="export-button">Export File</button>
            <button id="copy-build-btn" class="export-button">Copy to Clipboard</button>
        </div>
        <div class="import-container">
            <button id="import-build-btn" class="import-button">Import File</button>
        <button id="paste-build-btn" class="import-button">Paste from Clipboard</button>
        </div>
        </div>
    
        <p style="color: #888888;">This is fan-made and may have mistakes.</p>
        <p style="color: #888888;">Last Updated: Jul 7 </p>
        </div>
    </div>
    
    <script type="module">
    import itemsDatabase from './data/items.js';
    import statlist from './data/stats.js';
    import classesDatabase from './data/classes.js';
    import runesDatabase from './data/runes.js';
    import { Weapon, Item } from './data/types.js';
    

    const equippedItems = {
        helmet: null,
        chest: null,
        back: null,
        boots: null,
        ring1: null,
        ring2: null,
        ring3: null,
        ring4: null,
        race: null,
        weapon1: null,
        weapon2: null,
        offhand: null,
        lantern: null,
        fairy: null
    };

    const rarityOrder = {
        'common': 1,
        'uncommon': 2,
        'rare': 3,
        'epic': 4,
        'legendary': 5
    };

    const filterState = {
        search: '',
        stat: '',
        type: '',
        sort: 'name-asc'
    };

    window.itemsDatabase = itemsDatabase;

    const slots = document.querySelectorAll('.slot');
    let currentOpenMenu = null;

    function normalizarSlot(slotType) {
        const mapa = {
        weapon1: 'weapon',
        weapon2: 'weapon',
        };
        return mapa[slotType] || slotType;
    }

    const equippedRunes = {};

    document.querySelectorAll('.rune-slots').forEach(runeSlotsContainer => {
        const equipmentSlot = runeSlotsContainer.closest('.equipment-row').querySelector('.slot').dataset.slot;
        const runeSlots = {};
        
        runeSlotsContainer.querySelectorAll('.rune-slot').forEach((slot, index) => {
            const slotNumber = ['I', 'II', 'III', 'IV', 'V', 'VI'][index];
            runeSlots[slotNumber] = null;
        });
        
        equippedRunes[equipmentSlot] = runeSlots;
    });

    document.querySelectorAll('.rune-slot').forEach(runeSlot => {
    runeSlot.addEventListener('click', function() {
        const equipmentRow = this.closest('.equipment-row');
        const equipmentSlot = equipmentRow.querySelector('.slot').dataset.slot;
        const slotNumber = this.textContent;
        
        if (currentOpenMenu && currentOpenMenu.slot === this) {
            saveCurrentFilterState();
            document.body.removeChild(currentOpenMenu.menu);
            currentOpenMenu = null;
            return;
        }

        if (currentOpenMenu) {
            saveCurrentFilterState();
            document.body.removeChild(currentOpenMenu.menu);
            currentOpenMenu = null;
        }

        const menu = document.createElement('div');
        menu.className = 'item-menu rune-menu';
        menu.dataset.slotType = 'rune';

        menu.innerHTML = `
            <div class="menu-header-container">
                <div class="item-menu-header">
                    <input type="text" id="item-search" class="filter-input item-menu-search" 
                        placeholder="Search runes...">
                    <button id="reset-filters" class="menu-reset-button">Reset</button>
                </div>
                <div class="item-menu-filters">
                    <select id="stat-filter" class="filter-select">
                        <option value="">All Stats</option>
                    </select>
                    <select id="type-filter" class="filter-select">
                        <option value="">All Types</option>
                    </select>
                    <select id="sort-filter" class="filter-select">
                        <option value="name-asc">A-Z</option>
                        <option value="name-desc">Z-A</option>
                        <option value="rarity-asc">Rarity ↑</option>
                        <option value="rarity-desc">Rarity ↓</option>
                        <option value="stat-asc">Stat ↑</option>
                        <option value="stat-desc">Stat ↓</option>
                    </select>
                </div>
            </div>
            <div class="item-menu-content"></div>
        `;
        
        document.body.appendChild(menu);
        
        currentOpenMenu = {
            menu: menu,
            slot: this,
            equipmentSlot: equipmentSlot,
            slotNumber: slotNumber
        };

        const contentArea = menu.querySelector('.item-menu-content');
        initializeRuneFilters(menu, 'rune', menu.querySelector('.item-menu-content'));
        
        setTimeout(() => {
            restoreFilters(menu, 'rune');
        }, 0);
    });
});

function updateRuneMenu(menu, slotType, contentArea) {
    const searchTerm = menu.querySelector('#item-search').value.toLowerCase();
    const selectedStat = menu.querySelector('#stat-filter').value;
    const selectedType = menu.querySelector('#type-filter').value;
    const sortOption = menu.querySelector('#sort-filter').value;
    const equipmentSlot = currentOpenMenu?.equipmentSlot;
    const currentSlotNumber = currentOpenMenu?.slotNumber;
    
    contentArea.innerHTML = '';
    
    console.debug(equippedRunes);

    const runes = Object.entries(runesDatabase)
        .map(([key, rune]) => ({ key, rune }))
        .filter(({ rune }) => {
            const nameMatch = rune.name.toLowerCase().includes(searchTerm);
            
            let statMatch = true;
            if (selectedStat) {
                statMatch = rune.stats && rune.stats[selectedStat] !== undefined;
            }
            
            const nType = normalizarSlot(rune.type);
            const slotMatch = nType === 'null' || nType === normalizarSlot(equipmentSlot);
            
            let typeMatch = true;
            if (selectedType) {
                if (selectedType === 'null') {
                    typeMatch = nType === 'null';
                } else {
                    typeMatch = nType === selectedType;
                }
            }

            // Check for duplicates across all equipment slots
            let isDuplicate = false;
            if (nType !== 'null') {
                for (const [eqSlot, runeSlots] of Object.entries(equippedRunes)) {
                    // Only check for duplicates within the same equipment slot
                    if (eqSlot !== equipmentSlot) {
                        continue;
                    }
                    
                    for (const [slotNum, equippedRune] of Object.entries(runeSlots)) {
                        if (equippedRune && equippedRune.name.toLowerCase() === rune.name.toLowerCase()) {
                            // Skip if this is the same rune in the same slot (we're replacing it)
                            if (!(slotNum === currentSlotNumber)) {
                                isDuplicate = true;
                                break;
                            }
                        }
                    }
                    if (isDuplicate) break;
                }
            }
            
            return nameMatch && statMatch && slotMatch && typeMatch && !isDuplicate;
        })
            .sort((a, b) => {
                const runeA = a.rune;
                const runeB = b.rune;

                const sumStats = (rune) => {
                    let total = 0;
                    if (rune.stats) {
                        total += Object.values(rune.stats).reduce((sum, val) => sum + val, 0);
                    }
                    return total;
                };
                
                switch (sortOption) {
                    case 'name-asc':
                        return runeA.name.localeCompare(runeB.name);
                    case 'name-desc':
                        return runeB.name.localeCompare(runeA.name);
                    case 'rarity-asc':
                        return (rarityOrder[runeA.rarity || 'common'] || 0) - 
                            (rarityOrder[runeB.rarity || 'common'] || 0);
                    case 'rarity-desc':
                        return (rarityOrder[runeB.rarity || 'common'] || 0) - 
                            (rarityOrder[runeA.rarity || 'common'] || 0);
                    case 'stat-asc': {
                        if (!selectedStat) {
                            const sumA = sumStats(runeA);
                            const sumB = sumStats(runeB);
                            return sumA - sumB;
                        }
                        
                        const statA = runeA.stats?.[selectedStat] || 0;
                        const statB = runeB.stats?.[selectedStat] || 0;
                        return statA - statB;
                    }
                    case 'stat-desc': {
                        if (!selectedStat) {
                            const sumA = sumStats(runeA);
                            const sumB = sumStats(runeB);
                            return sumB - sumA;
                        }
                        
                        const statA = runeA.stats?.[selectedStat] || 0;
                        const statB = runeB.stats?.[selectedStat] || 0;
                        return statB - statA;
                    }
                    default:
                        return 0;
                }
            });
        
        runes.forEach(({ key, rune }) => {
    const button = document.createElement('button');
    button.textContent = rune.name;
    button.setAttribute('data-rarity', rune.rarity || 'common');
    button.setAttribute('data-rune-key', key);
    
    button.addEventListener('mouseenter', (e) => {
        const tooltipContent = createItemTooltipContent(rune);
        tooltipSystem.showTooltip(tooltipContent, button);
    });
    
    button.addEventListener('mouseleave', () => {
        tooltipSystem.hideTooltip();
    });
   
    button.onclick = () => {
    const slot = currentOpenMenu.slot;
    const equipmentSlot = currentOpenMenu.equipmentSlot;
    // Get the original slot number from data attribute instead of currentOpenMenu
    const slotNumber = slot.dataset.originalNumber; 
    
    // Update the slot with new rune
    slot.className = 'rune-slot filled';
    slot.setAttribute('data-rarity', rune.rarity || 'common');
    slot.setAttribute('data-rune-key', key);
    
    // Clear and rebuild the slot content safely
    slot.innerHTML = '';
    const contentDiv = document.createElement('div');
    contentDiv.className = 'slot-content';
    contentDiv.textContent = rune.name;
    slot.appendChild(contentDiv);
    
    const removeDiv = document.createElement('div');
    removeDiv.className = 'remove-rune';
    removeDiv.textContent = 'X';
    slot.appendChild(removeDiv);
    
    // Update equippedRunes with the new rune using the preserved slot number
    equippedRunes[equipmentSlot][slotNumber] = rune;
    
    tooltipSystem.hideTooltip();
    document.body.removeChild(currentOpenMenu.menu);
    currentOpenMenu = null;
    updateTotalStatsDisplay();
    
    const removeBtn = slot.querySelector('.remove-rune');
    removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        emptyRuneSlot(slot, equipmentSlot, slotNumber);
    });
    
    addRuneSlotHoverEvents(slot);
};

    contentArea.appendChild(button);
});
    
    if (runes.length === 0) {
        const noItemsMsg = document.createElement('div');
        noItemsMsg.className = 'no-items-message';
        noItemsMsg.textContent = 'No runes match your filters';
        contentArea.appendChild(noItemsMsg);
    }
    }

    function addRuneSlotHoverEvents(slot) {
        slot.addEventListener('mouseenter', (e) => {
            const runeKey = slot.getAttribute('data-rune-key');
            if (runeKey) {
                const rune = runesDatabase[runeKey];
                if (rune) {
                    const tooltipContent = createItemTooltipContent(rune);
                    tooltipSystem.showTooltip(tooltipContent, slot);
                }
            }
        });
        
        slot.addEventListener('mouseleave', () => {
            tooltipSystem.hideTooltip();
        });
        
        const removeBtn = slot.querySelector('.remove-rune');
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const equipmentRow = slot.closest('.equipment-row');
            const equipmentSlot = equipmentRow.querySelector('.slot').dataset.slot;
            const slotNumber = slot.dataset.originalNumber || slot.textContent.trim();
            emptyRuneSlot(slot, equipmentSlot, slotNumber);
        });
    }

    
    function emptyRuneSlot(slot, equipmentSlot, slotNumber) {
    if (!equipmentSlot || !slotNumber) {
        const equipmentRow = slot.closest('.equipment-row');
        if (equipmentRow) {
            equipmentSlot = equipmentSlot || equipmentRow.querySelector('.slot').dataset.slot;
            slotNumber = slotNumber || slot.dataset.originalNumber;
        }
    }

    // Clear the slot
    slot.className = 'rune-slot';
    slot.removeAttribute('data-rarity');
    slot.removeAttribute('data-rune-key');
    slot.textContent = slot.dataset.originalNumber || slotNumber;
    
    // Clear from equippedRunes
    if (equipmentSlot && slotNumber && equippedRunes[equipmentSlot]) {
        equippedRunes[equipmentSlot][slotNumber] = null;
    }
    
    updateTotalStatsDisplay();
    tooltipSystem.hideTooltip();

    if (currentOpenMenu) {
        saveCurrentFilterState();
        document.body.removeChild(currentOpenMenu.menu);
        currentOpenMenu = null;
    }
}

    function initializeClassSystem() {
        const classList = document.getElementById('class-list');
        const totalLevelsDisplay = document.getElementById('total-levels');
        let totalLevels = 0;
        
        Object.entries(classesDatabase).forEach(([className, classData]) => {
            const classItem = document.createElement('div');
            classItem.className = 'class-item';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'class-name';
            nameSpan.textContent = className;
            
            const input = document.createElement('input');
            input.type = 'number';
            input.className = 'class-level-input';
            input.min = 0;
            input.max = 50;
            input.value = 0;
            input.dataset.className = className;
            
            nameSpan.title = Object.entries(classData.stats)
                .map(([stat, value]) => `${stat}: +${value} per level`)
                .join('\n');
            
            classItem.appendChild(nameSpan);
            classItem.appendChild(input);
            classList.appendChild(classItem);
            
            input.addEventListener('change', updateClassLevels);
        });
        
        function updateClassLevels() {
            let newTotal = 0;
            const inputs = document.querySelectorAll('.class-level-input');
            
            inputs.forEach(input => {
                const value = parseInt(input.value) || 0;
                newTotal += value;
            });
            
            if (newTotal > 50) {
                this.value = Math.max(0, 50 - (newTotal - parseInt(this.value)));
                newTotal = 50;
                showLevelWarning();
            } else {
                hideLevelWarning();
            }
            
            totalLevels = newTotal;
            totalLevelsDisplay.textContent = totalLevels;
            updateTotalStatsDisplay();
        }
        
        function showLevelWarning() {
            let warning = document.querySelector('.level-warning');
            if (!warning) {
                warning = document.createElement('div');
                warning.className = 'level-warning';
                warning.textContent = 'Maximum 50 total levels across all classes!';
                classList.appendChild(warning);
            }
            warning.style.display = 'block';
            setTimeout(() => warning.style.display = 'none', 3000);
        }
        
        function hideLevelWarning() {
            const warning = document.querySelector('.level-warning');
            if (warning) warning.style.display = 'none';
        }
    }


    function calculateTotalStats() {
        const totalStats = {
            flat: {},
            percent: {},
            damage: {},
            armor: 0,
            posture: 0,
        };

        statlist.forEach(stat => {
            if (stat.percentual) {
            totalStats.percent[stat.stat] = 0;
            } else {
            totalStats.flat[stat.stat] = 0;
            }
        });

        const classInputs = document.querySelectorAll('.class-level-input');
        classInputs.forEach(input => {
            const className = input.dataset.className;
            const level = parseInt(input.value) || 0;
            const classData = classesDatabase[className];
            
            if (classData && level > 0) {
                Object.entries(classData.stats).forEach(([stat, value]) => {
                    const statValue = value * level;
                    const statInfo = statlist.find(s => s.stat === stat);
                    
                    if (statInfo) {
                        if (statInfo.percentual) {
                            totalStats.percent[stat] = (totalStats.percent[stat] || 0) + statValue;
                        } else {
                            totalStats.flat[stat] = (totalStats.flat[stat] || 0) + statValue;
                        }
                    }
                });
            }
        });

        const professionBonus = document.getElementById('level60-professions').checked;
        if (professionBonus) {
            ['strength', 'stamina', 'agility', 'intellect'].forEach(stat => {
                totalStats.flat[stat] = (totalStats.flat[stat] || 0) + 60;
            });
            totalStats.flat['spirit'] = (totalStats.flat['spirit'] || 0) + 30;
            totalStats.flat['luck'] = (totalStats.flat['luck'] || 0) + 7;
            totalStats.flat['maxWeight'] = (totalStats.flat['maxWeight'] || 0) + 150;
        }
        
        for (let i = 1; i <= 4; i++) {
            const ring = equippedItems[`ring${i}`];
            if (ring && ring.name && ring.name === 'Maelis\'s Ring') {
                if (equippedItems.fairy && equippedItems.fairy.name){
                    if (equippedItems.fairy.name == 'Golden Fairy'){
                        totalStats.flat['luck'] = (totalStats.flat['luck'] || 0) + 1;
                    }
                    else if (equippedItems.fairy.name == 'Fairy'){
                        totalStats.percent['magicAttack'] = (totalStats.flat['magicAttack'] || 0) + 0.08;
                    }
                    else if (equippedItems.fairy.name == 'Earth Fairy'){
                        totalStats.percent['earthAttack'] = (totalStats.flat['earthAttack'] || 0) + 0.05;
                    }
                    else if (equippedItems.fairy.name == 'Fire Fairy'){
                        totalStats.percent['fireAttack'] = (totalStats.flat['fireAttack'] || 0) + 0.05;
                    }
                    else if (equippedItems.fairy.name == 'Water Fairy'){
                        totalStats.percent['waterAttack'] = (totalStats.flat['waterAttack'] || 0) + 0.05;
                    }
                    else if (equippedItems.fairy.name == 'Lightning Fairy'){
                        totalStats.percent['lightningAttack'] = (totalStats.flat['lightningAttack'] || 0) + 0.05;
                    }
                    else if (equippedItems.fairy.name == 'Wind Fairy'){
                        totalStats.percent['windAttack'] = (totalStats.flat['windAttack'] || 0) + 0.05;
                    }
                }
                break;
            }
        }

        for (const [slot, item] of Object.entries(equippedItems)) {
            // weapon2 = secondary this makes it so that stats from secondary are skipped
            if (slot === 'weapon2') continue;
            if (item) {
            if (item.stats) {
                for (const [stat, value] of Object.entries(item.stats)) {
                const statInfo = statlist.find(s => s.stat === stat);
                if (statInfo) {
                    if (statInfo.percentual) {
                    totalStats.percent[stat] = (totalStats.percent[stat] || 0) + value;
                    } else {
                    totalStats.flat[stat] = (totalStats.flat[stat] || 0) + value;
                    }
                }
                }
            }

            if (item.damage) {
                for (const [type, value] of Object.entries(item.damage)) {
                totalStats.damage[type] = (totalStats.damage[type] || 0) + value;
                }
            }

            if (typeof item.armor === 'number') {
                totalStats.armor += item.armor;
            }

            if (typeof item.posture === 'number') {
                totalStats.posture += item.posture;
            }
            }
        }

        for (const [equipmentSlot, runeSlots] of Object.entries(equippedRunes)) {
            // Skip runes from secondary weapon
            if (equipmentSlot === 'weapon2') continue;
            for (const [slotNumber, rune] of Object.entries(runeSlots)) {
                if (rune) {
                    if (rune.stats) {
                        for (const [stat, value] of Object.entries(rune.stats)) {
                            const statInfo = statlist.find(s => s.stat === stat);
                            if (stat === 'armor') {
                            totalStats.armor += value;
                        } else if (statInfo.percentual) {
                            totalStats.percent[stat] = (totalStats.percent[stat] || 0) + value;
                        } else {
                            totalStats.flat[stat] = (totalStats.flat[stat] || 0) + value;
                        }
                        }
                    }
                }
            }
        }

        if (totalStats.flat.agility) {
            const critChanceFromAgility = totalStats.flat.agility * 0.00033;
            totalStats.percent.critChance = (totalStats.percent.critChance || 0) + critChanceFromAgility;
        }

        return totalStats;
        }

    function formatStatValue(value, isPercent) {
    if (isPercent) {
        return `${(value * 100).toFixed(1)}%`;
    }
    return Number.isInteger(value) ? value.toString() : value.toFixed(1);
    }

    function getStatInfo(statKey) {
        return statlist.find(s => s.stat === statKey);
    }

    function updateTotalStatsDisplay() {
        const totalStats = calculateTotalStats();
        const statsDisplay = document.querySelector('.stats-display');
        
         statsDisplay.innerHTML = `
            <div class="stats-column" id="column1"></div>
            <div class="stats-column" id="column2"></div>
        `;
        
        const column1 = document.getElementById('column1');
        const column2 = document.getElementById('column2');
        
        const column1Sections = ['Main', 'Critical', 'Attack', 'Mobility'];
        const column2Sections = ['Resistance', 'Duration', 'Resource', 'Miscellaneous'];
        
        const sections = {
            'Main': [],
            'Critical': [],
            'Attack': [],
            'Resistance': [],
            'Mobility': [],
            'Duration': [],
            'Resource': [],
            'Miscellaneous': []
        };

        for (const [stat, value] of Object.entries(totalStats.flat)) {
            if (value !== 0) {
            const statInfo = getStatInfo(stat);
            if (statInfo) {
                const category = statInfo.category || 'Miscellaneous';
                sections[category].push({
                    statInfo,
                    value,
                    isPercent: false
                });
            }
            }
        }
        
        for (const [stat, value] of Object.entries(totalStats.percent)) {
            if (value !== 0) {
            const statInfo = getStatInfo(stat);
            if (statInfo) {
                const category = statInfo.category || 'Miscellaneous';
                sections[category].push({
                    statInfo,
                    value,
                    isPercent: true
                });
            }
            }
        }

        for (const [type, value] of Object.entries(totalStats.damage)) {
            sections['Attack'].push({
            statInfo: {
                name: `${type.charAt(0).toUpperCase() + type.slice(1)} Damage`,
                stat: `damage-${type}`
            },
            value,
            isPercent: false
        });
        }

        if (totalStats.armor !== 0) {
            sections['Main'].push({
            statInfo: {
                name: 'Armor',
                stat: 'armor'
            },
            value: totalStats.armor,
            isPercent: false
        });
        }

        if (totalStats.posture !== 0) {
            sections['Main'].push({
            statInfo: {
                name: 'Posture',
                stat: 'posture'
            },
            value: totalStats.posture,
            isPercent: false
        });
        }

         column1Sections.forEach(sectionName => {
            const stats = sections[sectionName];
            if (stats.length > 0) {
                addStatsSection(column1, sectionName, stats);
            }
        });

        column2Sections.forEach(sectionName => {
            const stats = sections[sectionName];
            if (stats.length > 0) {
                addStatsSection(column2, sectionName, stats);
            }
        });
    }

    function addStatsSection(column, sectionName, stats) {
    const sectionDivider = document.createElement('div');
    sectionDivider.className = 'stat-section';
    sectionDivider.textContent = sectionName;
    column.appendChild(sectionDivider);
    
    stats.forEach(({statInfo, value, isPercent}) => {
        const statElement = document.createElement('div');
        statElement.className = 'stat-item stat-update';
        statElement.innerHTML = `
            <span class="stat-name">${statInfo.name}</span>
            <span class="stat-value ${value < 0 ? 'negative' : ''}">${value >= 0 ? '+' : ''}${formatStatValue(value, isPercent)}</span>
        `;

        if (statInfo.stat === 'critChance') {
            const tooltip = document.getElementById('custom-tooltip');
            const tooltipText = 'Crit chance is calculated with agility using the formula 1 agility = 0.033% crit. Please note that this may be incorrect.';

            statElement.addEventListener('mouseover', (event) => {
                tooltip.innerHTML = tooltipText;
                tooltip.style.display = 'block';
            });

            statElement.addEventListener('mousemove', (event) => {
                tooltip.style.left = (event.pageX + 15) + 'px';
                tooltip.style.top = (event.pageY + 15) + 'px';
            });

            statElement.addEventListener('mouseout', () => {
                tooltip.style.display = 'none';
            });
        }

        column.appendChild(statElement);
        
        setTimeout(() => {
            statElement.classList.remove('stat-update');
        }, 300);
    });
}

function initializeRuneFilters(menu, slotType, contentArea) {
    const statFilter = menu.querySelector('#stat-filter');
    const typeFilter = menu.querySelector('#type-filter');
    
    while (statFilter.options.length > 1) statFilter.remove(1);
    while (typeFilter.options.length > 1) typeFilter.remove(1);
    
    const statSet = new Set();
    const typeSet = new Set();
    const equipmentSlot = currentOpenMenu?.equipmentSlot;
    
    for (const runeId in runesDatabase) {
        const rune = runesDatabase[runeId];
        
        const normalizedRuneType = normalizarSlot(rune.type);
        const normalizedEquipmentSlot = normalizarSlot(equipmentSlot);
        
        if (normalizedRuneType === 'null' || normalizedRuneType === normalizedEquipmentSlot) {
            if (rune.stats) {
                Object.keys(rune.stats).forEach(stat => statSet.add(stat));
            }
            
            if (normalizedRuneType !== 'null' || normalizedRuneType === normalizedEquipmentSlot) {
                typeSet.add(normalizedRuneType === 'null' ? 'null' : normalizedRuneType);
            }
        }
    }
    
    statlist.forEach(stat => {
        if (statSet.has(stat.stat)) {
            const option = document.createElement('option');
            option.value = stat.stat;
            option.textContent = stat.name;
            statFilter.appendChild(option);
        }
    });
    
    const allTypes = Array.from(typeSet).sort();
    if (allTypes.length > 0) {
        allTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type === 'null' ? null : type;
            option.textContent = type === 'null' ? 'null' : 
                               type.charAt(0).toUpperCase() + type.slice(1);
            typeFilter.appendChild(option);
        });
    }
    
    const searchInput = menu.querySelector('#item-search');
    const sortFilter = menu.querySelector('#sort-filter');
    const resetButton = menu.querySelector('#reset-filters');
    
    const updateMenu = () => updateRuneMenu(menu, slotType, contentArea);
    
    searchInput.addEventListener('input', updateMenu);
    statFilter.addEventListener('change', updateMenu);
    typeFilter.addEventListener('change', updateMenu);
    sortFilter.addEventListener('change', updateMenu);
    resetButton.addEventListener('click', () => {
        searchInput.value = '';
        statFilter.value = '';
        typeFilter.value = '';
        sortFilter.value = 'name-asc';
        filterState.search = '';
        filterState.stat = '';
        filterState.type = '';
        filterState.sort = 'name-asc';
    });
    
    updateMenu();
}

    function initializeFilters(menu, slotType) {
        const contentArea = menu.querySelector('.item-menu-content');
        const statFilter = menu.querySelector('#stat-filter');
        const typeFilter = menu.querySelector('#type-filter');
        
        while (statFilter.options.length > 1) statFilter.remove(1);
        while (typeFilter.options.length > 1) typeFilter.remove(1);
        
        const statSet = new Set();
        const typeSet = new Set();
        
        for (const itemId in itemsDatabase[slotType]) {
        const item = itemsDatabase[slotType][itemId];
        
        if (item.stats) {
            Object.keys(item.stats).forEach(stat => statSet.add(stat));
        }
        
        if (typeof item.armor === 'number') {
            statSet.add('armor');
        }
        
        if (typeof item.posture === 'number') {
            statSet.add('posture');
        }
        
        if (item.damage) {
            Object.keys(item.damage).forEach(type => {
                statSet.add(`damage-${type}`);
            });
        }
        
        if (item.type) {
            typeSet.add(item.type);
        }
    }
    
    statlist.forEach(stat => {
        if (statSet.has(stat.stat)) {
            const option = document.createElement('option');
            option.value = stat.stat;
            option.textContent = stat.name;
            statFilter.appendChild(option);
        }
    });
    
    if (statSet.has('posture')) {
        const option = document.createElement('option');
        option.value = 'posture';
        option.textContent = 'Posture';
        statFilter.appendChild(option);
    }
    
    Array.from(statSet)
        .filter(stat => stat.startsWith('damage-'))
        .forEach(stat => {
            const damageType = stat.replace('damage-', '');
            const option = document.createElement('option');
            option.value = stat;
            option.textContent = `${damageType.charAt(0).toUpperCase() + damageType.slice(1)} Damage`;
            statFilter.appendChild(option);
        });
        
        Array.from(typeSet).sort().forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            typeFilter.appendChild(option);
        });
        
        const searchInput = menu.querySelector('#item-search');
        const sortFilter = menu.querySelector('#sort-filter');
        const resetButton = menu.querySelector('#reset-filters');
        
        const updateMenu = () => updateItemMenu(menu, slotType, contentArea);
        
        searchInput.addEventListener('input', updateMenu);
        statFilter.addEventListener('change', updateMenu);
        typeFilter.addEventListener('change', updateMenu);
        sortFilter.addEventListener('change', updateMenu);
        resetButton.addEventListener('click', () => {
            searchInput.value = '';
            statFilter.value = '';
            typeFilter.value = '';
            sortFilter.value = 'name-asc';
            updateMenu();
            filterState.search = '';
            filterState.stat = '';
            filterState.type = '';
            filterState.sort = 'name-asc';
        });
        
        updateMenu();
    }

    function resetFilters() {

        document.getElementById('item-search').value = '';
        document.getElementById('stat-filter').value = '';
        document.getElementById('type-filter').value = '';
        document.getElementById('sort-filter').value = 'name-asc';
        updateItemMenu();
    }

    function updateItemMenu(menu, slotType, contentArea) {
    const searchTerm = menu.querySelector('#item-search').value.toLowerCase();
    const selectedStat = menu.querySelector('#stat-filter').value;
    const selectedType = menu.querySelector('#type-filter').value;
    const sortOption = menu.querySelector('#sort-filter').value;
    
    contentArea.innerHTML = '';
    
    const equippedRingNames = [];
    for (let i = 1; i <= 4; i++) {
        const ring = equippedItems[`ring${i}`];
        if (ring && ring.name) {
            equippedRingNames.push(ring.name.toLowerCase());
        }
    }

    const items = Object.entries(itemsDatabase[slotType] || {})
        .map(([key, item]) => ({ key, item }))
        .filter(({ item }) => {
            const nameMatch = item.name.toLowerCase().includes(searchTerm);
            
            let statMatch = true;
            if (selectedStat) {
                if (selectedStat === 'armor') {
                    statMatch = typeof item.armor === 'number';
                } else if (selectedStat === 'posture') {
                    statMatch = typeof item.posture === 'number';
                } else if (selectedStat.startsWith('damage-')) {
                    const damageType = selectedStat.replace('damage-', '');
                    statMatch = item.damage && typeof item.damage[damageType] === 'number';
                } else {
                    statMatch = item.stats && item.stats[selectedStat] !== undefined;
                }
            }
            
            let typeMatch = true;
            if (selectedType) {
                typeMatch = item.type === selectedType;
            }

            let duplicateRing = false;
            if (slotType === 'ring') {
                duplicateRing = equippedRingNames.includes(item.name.toLowerCase());
            }
            
            return nameMatch && statMatch && typeMatch && !duplicateRing;
        })
        .sort((a, b) => {
            const itemA = a.item;
            const itemB = b.item;

            const sumStats = (item) => {
                let total = 0;
                if (item.stats) {
                    total += Object.values(item.stats).reduce((sum, val) => sum + val, 0);
                }
                if (typeof item.armor === 'number') {
                    total += item.armor;
                }
                if (typeof item.posture === 'number') {
                    total += item.posture;
                }
                if (item.damage) {
                    total += Object.values(item.damage).reduce((sum, val) => sum + val, 0);
                }
                return total;
            };
            
            switch (sortOption) {
                case 'name-asc':
                    return itemA.name.localeCompare(itemB.name);
                case 'name-desc':
                    return itemB.name.localeCompare(itemA.name);
                case 'rarity-asc':
                    return (rarityOrder[itemA.rarity || 'common'] || 0) - 
                           (rarityOrder[itemB.rarity || 'common'] || 0);
                case 'rarity-desc':
                    return (rarityOrder[itemB.rarity || 'common'] || 0) - 
                           (rarityOrder[itemA.rarity || 'common'] || 0);
                case 'stat-asc': {
                    if (!selectedStat) {
                        const sumA = sumStats(itemA);
                        const sumB = sumStats(itemB);
                        return sumA - sumB;
                    }
                    
                    let statA = itemA.stats?.[selectedStat] || 0;
                    let statB = itemB.stats?.[selectedStat] || 0;
                    
                    if (selectedStat === 'armor') {
                        statA = itemA.armor || 0;
                        statB = itemB.armor || 0;
                    } else if (selectedStat === 'posture') {
                        statA = itemA.posture || 0;
                        statB = itemB.posture || 0;
                    } else if (selectedStat.startsWith('damage-')) {
                        const damageType = selectedStat.replace('damage-', '');
                        statA = itemA.damage?.[damageType] || 0;
                        statB = itemB.damage?.[damageType] || 0;
                    }
                    
                    return statA - statB;
                }
                case 'stat-desc': {
                    if (!selectedStat) {
                        const sumA = sumStats(itemA);
                        const sumB = sumStats(itemB);
                        return sumB - sumA;
                    }
                    
                    let statA = itemA.stats?.[selectedStat] || 0;
                    let statB = itemB.stats?.[selectedStat] || 0;
                    
                    if (selectedStat === 'armor') {
                        statA = itemA.armor || 0;
                        statB = itemB.armor || 0;
                    } else if (selectedStat === 'posture') {
                        statA = itemA.posture || 0;
                        statB = itemB.posture || 0;
                    } else if (selectedStat.startsWith('damage-')) {
                        const damageType = selectedStat.replace('damage-', '');
                        statA = itemA.damage?.[damageType] || 0;
                        statB = itemB.damage?.[damageType] || 0;
                    }
                    return statB - statA;
                }
                default:
                    return 0;
            }
        });
    
    items.forEach(({ key, item }) => {
        const nome = item.name || key;
        const botao = document.createElement('button');
        botao.textContent = `${nome}`;
        botao.setAttribute('data-rarity', item.rarity || 'common');
        botao.setAttribute('data-item-key', key);
        botao.setAttribute('data-slot-type', slotType);
        
        botao.onclick = () => {
            const slot = currentOpenMenu.slot;
            slot.className = 'slot filled';
            slot.setAttribute('data-rarity', item.rarity || 'common');
            slot.innerHTML = `
                <div class="slot-content">${nome}</div>
                <div class="remove-item">X</div>
            `;
            
            const slotKey = slot.dataset.slot === 'ring' ? 
                `ring${slot.dataset.ringNumber}` : 
                slot.dataset.slot;
            equippedItems[slotKey] = item;
            
            tooltipSystem.hideTooltip();
            saveCurrentFilterState();
            document.body.removeChild(currentOpenMenu.menu);
            currentOpenMenu = null;
            updateTotalStatsDisplay();
            
            const removeBtn = slot.querySelector('.remove-item');
            removeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                emptySlot(slot, slotKey);
            });
        };
        
        contentArea.appendChild(botao);
    });
    
    if (items.length === 0) {
        const noItemsMsg = document.createElement('div');
        noItemsMsg.className = 'no-items-message';
        noItemsMsg.textContent = 'No items match your filters';
        contentArea.appendChild(noItemsMsg);
    }
}

    slots.forEach(slot => {
    slot.addEventListener('click', () => {
        const slotType = slot.dataset.slot;
        const slotChave = normalizarSlot(slotType);

        if (currentOpenMenu && currentOpenMenu.slot === slot) {
            saveCurrentFilterState();
            document.body.removeChild(currentOpenMenu.menu);
            currentOpenMenu = null;
            return;
        }

        if (currentOpenMenu) {
            saveCurrentFilterState();
            document.body.removeChild(currentOpenMenu.menu);
            currentOpenMenu = null;
        }

        const banco = window.itemsDatabase?.[slotChave];
        if (!banco || Object.keys(banco).length === 0) {
            alert("No item available for this slot.");
            return;
        }

        const menu = document.createElement('div');
        menu.className = 'item-menu';
        menu.dataset.slotType = slotChave;

        const headerContainer = document.createElement('div');
        headerContainer.className = 'menu-header-container';

        const menuHeader = document.createElement('div');
        menuHeader.className = 'item-menu-header';
        
        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.id = 'item-search';
        searchInput.className = 'filter-input item-menu-search';
        searchInput.placeholder = 'Search items...';
        
        const resetButton = document.createElement('button');
        resetButton.id = 'reset-filters';
        resetButton.className = 'menu-reset-button';
        resetButton.innerHTML = 'Reset';
        resetButton.title = 'Reset filters';
        
        menuHeader.appendChild(searchInput);
        menuHeader.appendChild(resetButton);
        
        const filtersContainer = document.createElement('div');
        filtersContainer.className = 'item-menu-filters';
        
        const statFilter = document.createElement('select');
        statFilter.id = 'stat-filter';
        statFilter.className = 'filter-select';
        
        const typeFilter = document.createElement('select');
        typeFilter.id = 'type-filter';
        typeFilter.className = 'filter-select';
        
        const sortFilter = document.createElement('select');
        sortFilter.id = 'sort-filter';
        sortFilter.className = 'filter-select';
        
        const sortOptions = [
            {value: 'name-asc', text: 'A-Z'},
            {value: 'name-desc', text: 'Z-A'},
            {value: 'rarity-asc', text: 'Rarity ↑'},
            {value: 'rarity-desc', text: 'Rarity ↓'},
            {value: 'stat-asc', text: 'Stat ↑'},
            {value: 'stat-desc', text: 'Stat ↓'}
        ];
        
        sortOptions.forEach(option => {
            const optElement = document.createElement('option');
            optElement.value = option.value;
            optElement.textContent = option.text;
            sortFilter.appendChild(optElement);
        });
        
        const addDefaultOption = (select, text) => {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = text;
            select.appendChild(option);
        };
        
        addDefaultOption(statFilter, 'All Stats');
        addDefaultOption(typeFilter, 'All Types');
        
        filtersContainer.appendChild(statFilter);
        filtersContainer.appendChild(typeFilter);
        filtersContainer.appendChild(sortFilter);
        
        headerContainer.appendChild(menuHeader);
        headerContainer.appendChild(filtersContainer);
        
        const menuContent = document.createElement('div');
        menuContent.className = 'item-menu-content';
        
        menu.appendChild(headerContainer);
        menu.appendChild(menuContent);
        
        document.body.appendChild(menu);
        
        currentOpenMenu = {
            menu: menu,
            slot: slot
        };
        
        setTimeout(() => {
            restoreFilters(menu, slotChave);
        }, 0);
        
        currentOpenMenu = {
            menu: menu,
            slot: slot
        };

        initializeFilters(menu, slotChave);
    });
});

    function saveCurrentFilterState() {
    if (!currentOpenMenu) return;
    
    const menu = currentOpenMenu.menu;
    filterState.search = menu.querySelector('#item-search').value;
    filterState.stat = menu.querySelector('#stat-filter').value;
    filterState.type = menu.querySelector('#type-filter').value;
    filterState.sort = menu.querySelector('#sort-filter').value;
}

function restoreFilters(menu, slotType) {
    const searchInput = menu.querySelector('#item-search');
    const statFilter = menu.querySelector('#stat-filter');
    const typeFilter = menu.querySelector('#type-filter');
    const sortFilter = menu.querySelector('#sort-filter');
    
    searchInput.value = filterState.search;
    sortFilter.value = filterState.sort;
    
    if (filterState.stat) {
        const statExists = Array.from(statFilter.options).some(
            opt => opt.value === filterState.stat
        );
        if (statExists) {
            statFilter.value = filterState.stat;
        } else {
            statFilter.value = '';
            filterState.stat = '';
        }
    }
    
    if (filterState.type) {
        const typeExists = Array.from(typeFilter.options).some(
            opt => opt.value === filterState.type
        );
        if (typeExists) {
            typeFilter.value = filterState.type;
        } else {
            typeFilter.value = '';
            filterState.type = '';
        }
    }
    
    const contentArea = menu.querySelector('.item-menu-content');
    if (slotType === 'rune') {
        updateRuneMenu(menu, slotType, contentArea);
    } else {
        updateItemMenu(menu, slotType, contentArea);
    }
}

    function emptySlot(slot, slotKey) {
        slot.className = 'slot';
        slot.removeAttribute('data-rarity');
        slot.innerHTML = slot.dataset.slot.charAt(0).toUpperCase() + slot.dataset.slot.slice(1);
        equippedItems[slotKey] = null;
        updateTotalStatsDisplay();
        tooltipSystem.hideTooltip();
        if (currentOpenMenu) {
            saveCurrentFilterState();
            document.body.removeChild(currentOpenMenu.menu);
            currentOpenMenu = null;
        }
    }

    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';
document.body.appendChild(tooltip);

function createItemTooltipContent(item) {
        const tooltipContent = document.createElement('div');

        const header = document.createElement('div');
        header.className = 'tooltip-header';
        
        const nameElement = document.createElement('div');
        nameElement.className = `tooltip-name ${item.rarity || 'common'}`;
        nameElement.textContent = item.name || 'Unnamed Item';
        
        const headerRight = document.createElement('div');
        headerRight.className = 'tooltip-header-right';
        
        const rarityElement = document.createElement('div');
        rarityElement.className = `tooltip-rarity ${item.rarity || 'common'}`;
        rarityElement.textContent = item.rarity || 'common';

        if (typeof item.level === 'number') {
            const levelElement = document.createElement('div');
            levelElement.className = 'tooltip-level';
            levelElement.textContent = `Lv. ${item.level}`;
            headerRight.appendChild(levelElement);
        }
        
        header.appendChild(nameElement);
        header.appendChild(headerRight);
        tooltipContent.appendChild(header);
        
        if (item.type && item.type !== 'null') {
            const typeElement = document.createElement('div');
            typeElement.className = 'tooltip-type';
            typeElement.textContent = `${item.type.charAt(0).toUpperCase() + item.type.slice(1)}`;
            tooltipContent.appendChild(typeElement);
        }

        if (typeof item.armor === 'number') {
            const armorElement = document.createElement('div');
            armorElement.className = 'tooltip-stat';
            
            const armorName = document.createElement('div');
            armorName.className = 'tooltip-stat-name';
            armorName.textContent = 'Armor';
            
            const armorValue = document.createElement('div');
            armorValue.className = `tooltip-stat-value ${item.armor >= 0 ? 'positive' : 'negative'}`;
            armorValue.textContent = `${item.armor}`;
            
            armorElement.appendChild(armorName);
            armorElement.appendChild(armorValue);
            tooltipContent.appendChild(armorElement);
        }

        if (typeof item.posture === 'number') {
            const postureElement = document.createElement('div');
            postureElement.className = 'tooltip-stat';
            
            const postureName = document.createElement('div');
            postureName.className = 'tooltip-stat-name';
            postureName.textContent = 'Posture';
            
            const postureValue = document.createElement('div');
            postureValue.className = `tooltip-stat-value ${item.posture >= 0 ? 'positive' : 'negative'}`;
            postureValue.textContent = `${item.posture}`;
            
            postureElement.appendChild(postureName);
            postureElement.appendChild(postureValue);
            tooltipContent.appendChild(postureElement);
        }

        if (item.damage && Object.keys(item.damage).length > 0) {
            for (const [damageType, value] of Object.entries(item.damage)) {
                const damageElement = document.createElement('div');
                damageElement.className = 'tooltip-stat';
                
                const damageName = document.createElement('div');
                damageName.className = 'tooltip-stat-name';
                damageName.textContent = `${damageType.charAt(0).toUpperCase() + damageType.slice(1)} Damage`;
                
                const damageValue = document.createElement('div');
                damageValue.className = `tooltip-stat-value ${value >= 0 ? 'positive' : 'negative'}`;
                damageValue.textContent = `${value}`;
                
                damageElement.appendChild(damageName);
                damageElement.appendChild(damageValue);
                tooltipContent.appendChild(damageElement);
            }
        }

        if (item.stats && Object.keys(item.stats).length > 0) {
            const statsContainer = document.createElement('div');
            statsContainer.className = 'tooltip-stats';
            
            for (const [stat, value] of Object.entries(item.stats)) {
                const statInfo = getStatInfo(stat);
                if (statInfo) {
                    const statElement = document.createElement('div');
                    statElement.className = 'tooltip-stat';
                    
                    const statName = document.createElement('div');
                    statName.className = 'tooltip-stat-name';
                    statName.textContent = statInfo.name;
                    
                    const statValue = document.createElement('div');
                    statValue.className = `tooltip-stat-value ${value >= 0 ? 'positive' : 'negative'}`;
                    statValue.textContent = `${formatStatValue(value, statInfo.percentual)}`;
                    
                    statElement.appendChild(statName);
                    statElement.appendChild(statValue);
                    statsContainer.appendChild(statElement);
                }
            }
            
            tooltipContent.appendChild(statsContainer);
        }
        
        if (item.description) {
            const descElement = document.createElement('div');
            descElement.className = 'tooltip-description';
            descElement.textContent = item.description;
            tooltipContent.appendChild(descElement);
        }
        
        return tooltipContent;
    }

const tooltipSystem = {
  currentTooltip: null,
  
  showTooltip: function(content, element) {
    this.hideTooltip();
    
    this.currentTooltip = document.createElement('div');
    this.currentTooltip.className = 'tooltip';
    this.currentTooltip.appendChild(content);
    document.body.appendChild(this.currentTooltip);
    
    this.positionTooltip(element);
    this.currentTooltip.classList.add('visible');
  },
  
  positionTooltip: function(element) {
    const rect = element.getBoundingClientRect();
    const tooltip = this.currentTooltip;
    
    let left = rect.right + 10;
    let top = rect.top + window.scrollY;
    
    tooltip.style.visibility = 'hidden';
    tooltip.style.display = 'block';
    const tooltipRect = tooltip.getBoundingClientRect();
    tooltip.style.visibility = '';
    tooltip.style.display = '';
    
    if (left + tooltipRect.width > window.innerWidth) {
        left = rect.left - tooltipRect.width - 10;
    }
    
    if (top + tooltipRect.height > window.innerHeight + window.scrollY) {
        top = rect.top + window.scrollY - (tooltipRect.height/2);
        
        if (top < window.scrollY) {
            top = window.innerHeight + window.scrollY - tooltipRect.height - 10;
        }
    }
    
    if (top < window.scrollY) {
        top = window.scrollY + 10;
    }
    
    tooltip.style.left = `${left}px`;
    tooltip.style.top = `${top}px`;
},
  
  hideTooltip: function() {
    if (this.currentTooltip) {
      document.body.removeChild(this.currentTooltip);
      this.currentTooltip = null;
    }
  }
};

    slots.forEach(slot => {
      slot.addEventListener('mouseenter', (e) => {
        const slotType = slot.dataset.slot;
        let slotKey;
        
        if (slotType === 'ring') {
          // For rings, use the ring-number attribute to get the correct key
          slotKey = `ring${slot.dataset.ringNumber}`;
        } else {
          slotKey = slotType;
        }
        
        const item = equippedItems[slotKey];
        if (item) {
          const tooltipContent = createItemTooltipContent(item);
          tooltipSystem.showTooltip(tooltipContent, slot);
        }
      });
      
      slot.addEventListener('mouseleave', () => {
        tooltipSystem.hideTooltip();
      });
    });

document.addEventListener('mouseover', (e) => {
  const button = e.target.closest('.item-menu button');
  if (button) {
    const itemKey = button.getAttribute('data-item-key');
    const runeKey = button.getAttribute('data-rune-key');
    const slotType = button.closest('.item-menu').dataset.slotType;
    
    let item;
    if (itemKey && slotType !== 'rune') {
      item = window.itemsDatabase?.[slotType]?.[itemKey];
    } else if (runeKey && slotType === 'rune') {
      item = window.runesDatabase?.[runeKey];
    }
    
    if (item) {
      const tooltipContent = createItemTooltipContent(item);
      tooltipSystem.showTooltip(tooltipContent, button);
    }
  }
}, true);

document.addEventListener('mouseout', (e) => {
  if (!e.relatedTarget || !e.relatedTarget.closest('.item-menu button, .slot')) {
    tooltipSystem.hideTooltip();
  }
}, true);

function copyBuildToClipboard() {
    const buildData = gatherBuildData();
    const compressed = compressBuildData(buildData);
    
    navigator.clipboard.writeText(compressed)
        .then(() => {
            showNotification('Build copied to clipboard!');
        })
        .catch(err => {
            console.error('Failed to copy: ', err);
            showNotification('Failed to copy to clipboard', true);
        });
}

function pasteBuildFromClipboard() {
    navigator.clipboard.readText()
        .then(text => {
            // Try to detect if it's compressed or old format
            let buildData;
            if (text.startsWith('{') && text.endsWith('}')) {
                // Old uncompressed format
                try {
                    buildData = JSON.parse(text);
                    showNotification('Legacy build imported (not compressed)');
                } catch (error) {
                    console.error('Error parsing JSON: ', error);
                    showNotification('Invalid build data in clipboard', true);
                    return;
                }
            } else {
                // New compressed format
                buildData = decompressBuildData(text);
                if (!buildData) {
                    showNotification('Invalid compressed build data', true);
                    return;
                }
                showNotification('Build pasted from clipboard!');
            }
            
            loadBuildData(buildData);
        })
        .catch(err => {
            console.error('Failed to read clipboard: ', err);
            showNotification('Failed to read clipboard', true);
        });
}

function showNotification(message, isError = false) {
    const notification = document.createElement('div');
    notification.className = `notification ${isError ? 'error' : 'success'}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    void notification.offsetWidth;
    
    setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 3000);
}

function compressBuildData(buildData) {
    const jsonString = JSON.stringify(buildData);
    const compressed = LZString.compressToBase64(jsonString);
    return compressed;
}

function decompressBuildData(compressedString) {
    try {
        const jsonString = LZString.decompressFromBase64(compressedString);
        if (!jsonString) throw new Error("Invalid compressed data");
        return JSON.parse(jsonString);
    } catch (error) {
        console.error("Decompression error:", error);
        return null;
    }
}

function gatherBuildData() {
    const itemsData = {};
    for (const [slot, item] of Object.entries(equippedItems)) {
        if (item) {
            itemsData[slot] = {
                name: item.name,
                runeslots: item.runeslots || 0
            };
        } else {
            itemsData[slot] = null;
        }
    }

    const runesData = {};
    const validSlotNumbers = ['I', 'II', 'III', 'IV', 'V', 'VI'];
    
    for (const [equipmentSlot, runeSlots] of Object.entries(equippedRunes)) {
        runesData[equipmentSlot] = {};
        
        // Get max slots from equipped item or default to 0
        const maxSlots = equippedItems[equipmentSlot]?.runeslots || 0;
        
        // Only process valid slot numbers up to the max slots
        for (let i = 0; i < Math.min(maxSlots, validSlotNumbers.length); i++) {
            const slotNumber = validSlotNumbers[i];
            const rune = runeSlots[slotNumber];
            
            if (rune) {
                runesData[equipmentSlot][slotNumber] = {
                    name: rune.name
                };
            } else {
                runesData[equipmentSlot][slotNumber] = null;
            }
        }
    }

    const classLevels = {};
    const classInputs = document.querySelectorAll('.class-level-input');
    classInputs.forEach(input => {
        const className = input.dataset.className;
        const level = parseInt(input.value) || 0;
        classLevels[className] = level;
    });

    const professionBonus = document.getElementById('level60-professions').checked;

    const buildData = {
        items: itemsData,
        runes: runesData,
        classes: classLevels,
        professionBonus: professionBonus,
        timestamp: new Date().toISOString()
    };

    return buildData;
}
    async function exportBuild() {
        try {
            const buildData = gatherBuildData();
            
            // Deep clean the rune data (your existing cleaning code)
            const cleanedRunes = {};
            const validSlotNumbers = ['I', 'II', 'III', 'IV', 'V', 'VI'];
            
            for (const [equipmentSlot, runeSlots] of Object.entries(buildData.runes)) {
                cleanedRunes[equipmentSlot] = {};
                const maxSlots = buildData.items[equipmentSlot]?.runeslots || 0;
                
                for (let i = 0; i < Math.min(maxSlots, validSlotNumbers.length); i++) {
                    const slotNumber = validSlotNumbers[i];
                    if (runeSlots[slotNumber]) {
                        cleanedRunes[equipmentSlot][slotNumber] = runeSlots[slotNumber];
                    }
                }
            }
            
            const cleanedBuildData = {
                ...buildData,
                runes: cleanedRunes
            };
            
            const jsonString = JSON.stringify(cleanedBuildData, (key, value) => {
                if (typeof key === 'string' && key.includes('\n')) {
                    return undefined;
                }
                return value;
            }, 2);
            
            // Default filename (same as your current one)
            const date = new Date();
            const dateString = date.toISOString().slice(0, 10);
            const timeString = date.toTimeString().slice(0, 8).replace(/:/g, '-');
            const defaultFilename = `rune-slayer-build-${dateString}_${timeString}.json`;
            
            // Try using the File System Access API
            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: defaultFilename,
                        types: [{
                            description: 'JSON Files',
                            accept: {
                                'application/json': ['.json'],
                            },
                        }],
                    });
                    
                    const writable = await handle.createWritable();
                    await writable.write(jsonString);
                    await writable.close();
                    
                    showNotification('Build exported successfully!');
                    return;
                } catch (err) {
                    // User canceled the save dialog
                    if (err.name !== 'AbortError') {
                        console.error('Error using File System Access API:', err);
                        // Fall through to legacy method
                    } else {
                        return; // User cancelled, do nothing
                    }
                }
            }
            
            // Fallback for browsers that don't support File System Access API
            const blob = new Blob([jsonString], { type: 'application/json' });
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = URL.createObjectURL(blob);
            a.download = defaultFilename;
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            }, 100);
            
            showNotification('Build exported successfully!');
        } catch (error) {
            console.error('Error exporting build:', error);
            showNotification('Error exporting build!', 'error');
        }
    }
    function importBuild() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        
        input.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = event => {
                try {
                    const buildData = JSON.parse(event.target.result);
                    loadBuildData(buildData);
                } catch (error) {
                    alert('Error parsing build file: ' + error.message);
                }
            };
            reader.readAsText(file);
        };
        
        input.click();
    }
    
    function loadBuildData(buildData) {
        try {
            // Clear existing runes first
            for (const equipmentSlot in equippedRunes) {
                for (const slotNumber in equippedRunes[equipmentSlot]) {
                    equippedRunes[equipmentSlot][slotNumber] = null;
                    const equipmentRow = document.querySelector(`.slot[data-slot="${equipmentSlot}"]`)?.closest('.equipment-row');
                    if (equipmentRow) {
                        const runeSlot = equipmentRow.querySelector(`.rune-slot[data-original-number="${slotNumber}"]`);
                        if (runeSlot) {
                            runeSlot.className = 'rune-slot';
                            runeSlot.textContent = slotNumber;
                            runeSlot.removeAttribute('data-rarity');
                            runeSlot.removeAttribute('data-rune-key');
                        }
                    }
                }
            }

            for (const equipmentSlot in equippedRunes) {
                for (const slotNumber in equippedRunes[equipmentSlot]) {
                    equippedRunes[equipmentSlot][slotNumber] = null;
                    const equipmentRow = document.querySelector(`.slot[data-slot="${equipmentSlot}"]`).closest('.equipment-row');
                    if (equipmentRow) {
                        const runeSlot = equipmentRow.querySelector(`.rune-slot[data-original-number="${slotNumber}"]`);
                        if (runeSlot) {
                            runeSlot.className = 'rune-slot';
                            runeSlot.textContent = slotNumber;
                            runeSlot.removeAttribute('data-rarity');
                            runeSlot.removeAttribute('data-rune-key');
                        }
                    }
                }
            }

            if (buildData.items) {
            for (const [slot, itemData] of Object.entries(buildData.items)) {
                if (itemData) {
                    let item = null;
                    let itemKey = null;
                    
                    const slotType = slot.startsWith('ring') ? 'ring' : 
                                     slot === 'weapon1' || slot === 'weapon2' ? 'weapon' : 
                                     slot;
                    
                    if (itemsDatabase[slotType]) {
                        for (const [key, dbItem] of Object.entries(itemsDatabase[slotType])) {
                            if (dbItem.name === itemData.name) {
                                item = dbItem;
                                itemKey = key;
                                break;
                            }
                        }
                    }
                    
                    if (item) {
                        equippedItems[slot] = item;
                        
                        const slotElement = document.querySelector(`.slot[data-slot="${slot}"]`) || 
                                           document.querySelector(`.slot[data-slot="ring"][data-ring-number="${slot.replace('ring', '')}"]`);
                        
                        if (slotElement) {
                            slotElement.className = 'slot filled';
                            slotElement.setAttribute('data-rarity', item.rarity || 'common');
                            slotElement.innerHTML = `
                                <div class="slot-content">${item.name}</div>
                                <div class="remove-item">X</div>
                            `;
                            
                            const removeBtn = slotElement.querySelector('.remove-item');
                            removeBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                emptySlot(slotElement, slot);
                            });
                        }
                    }
                }
            }
        }
             
            if (buildData.runes) {
                for (const [equipmentSlot, runeSlots] of Object.entries(buildData.runes)) {
                    const equipmentRow = document.querySelector(`.slot[data-slot="${equipmentSlot}"]`)?.closest('.equipment-row');
                    
                    if (equipmentRow) {
                        for (const [slotNumber, runeData] of Object.entries(runeSlots)) {
                            if (runeData && runeData.name) {  // Ensure runeData has a name property
                                const runeKey = findRuneKeyByName(runeData.name);
                                if (runeKey) {
                                    const rune = runesDatabase[runeKey];
                                    const runeSlot = equipmentRow.querySelector(`.rune-slot[data-original-number="${slotNumber}"]`);
                                    
                                    if (runeSlot) {
                                        runeSlot.className = 'rune-slot filled';
                                        runeSlot.setAttribute('data-rarity', rune.rarity || 'common');
                                        runeSlot.setAttribute('data-rune-key', runeKey);
                                        
                                        // Clear and rebuild the slot content safely
                                        runeSlot.innerHTML = '';
                                        
                                        const contentDiv = document.createElement('div');
                                        contentDiv.className = 'slot-content';
                                        contentDiv.textContent = rune.name;
                                        runeSlot.appendChild(contentDiv);
                                        
                                        const removeDiv = document.createElement('div');
                                        removeDiv.className = 'remove-rune';
                                        removeDiv.textContent = 'X';
                                        runeSlot.appendChild(removeDiv);
                                        
                                        equippedRunes[equipmentSlot][slotNumber] = rune;
                                        
                                        const removeBtn = runeSlot.querySelector('.remove-rune');
                                        removeBtn.addEventListener('click', (e) => {
                                            e.stopPropagation();
                                            emptyRuneSlot(runeSlot, equipmentSlot, slotNumber);
                                        });
                                        
                                        addRuneSlotHoverEvents(runeSlot);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (buildData.classes) {
            let totalImportedLevels = 0;
            
            const classInputs = document.querySelectorAll('.class-level-input');
            classInputs.forEach(input => {
                const className = input.dataset.className;
                if (buildData.classes[className]) {
                    const level = parseInt(buildData.classes[className]) || 0;
                    input.value = level;
                    totalImportedLevels += level;
                } else {
                    input.value = 0;
                }
            });

            const totalLevelsDisplay = document.getElementById('total-levels');
            totalLevelsDisplay.textContent = totalImportedLevels;
        }

            if (buildData.professionBonus !== undefined) {
                document.getElementById('level60-professions').checked = buildData.professionBonus;
            }

            updateTotalStatsDisplay();
        } catch (error) {
            console.error('Error loading build:', error);
            alert('Error loading build: ' + error.message);
        }
    }

    function findRuneKeyByName(name) {
        for (const key in runesDatabase) {
            if (runesDatabase[key].name === name) {
                return key;
            }
        }
        return null;
    }


    document.getElementById('copy-build-btn').addEventListener('click', copyBuildToClipboard);
    
    document.getElementById('paste-build-btn').addEventListener('click', pasteBuildFromClipboard);

    document.getElementById('import-build-btn').addEventListener('click', importBuild);

    document.getElementById('export-build-btn').addEventListener('click', exportBuild);

    document.getElementById('level60-professions').addEventListener('change', updateTotalStatsDisplay);

    document.addEventListener('click', (e) => {
        if (currentOpenMenu && 
            !e.target.closest('.item-menu') && 
            !e.target.closest('.slot') && 
            !e.target.closest('.rune-slot')) {
            
            saveCurrentFilterState();
            document.body.removeChild(currentOpenMenu.menu);
            currentOpenMenu = null;
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        initializeClassSystem();
        updateTotalStatsDisplay();
        document.querySelectorAll('.rune-slot.filled').forEach(slot => {
            addRuneSlotHoverEvents(slot);
        });
    });
</script>
</body>

</html>